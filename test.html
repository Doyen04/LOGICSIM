<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas width="400" height="400">

    </canvas>
</body>
<script>
    //[x:50 y:50][250 50][250 300] 50 30
    const radius = 15;

    class CustomArray extends Array {
        add(array) {
            return new CustomArray(this[0] + array[0], this[1] + array[1]);
        }
        minus(array) {
            return new CustomArray(this[0] - array[0], this[1] - array[1]);
        }
        divideBy(num) {
            return new CustomArray(this[0] / num, this[1] / num);
        }
        multiplyBy(num) {
            return new CustomArray(this[0] * num, this[1] * num);
        }
    }

    class Vector2 extends Array {
        vecLength() {
            const [p1, p2] = this.map(p => new CustomArray(...p));
            return Math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2);
        }
        normalise() {
            const [p1, p2] = this.map(p => new CustomArray(...p));
            const direction = p2.minus(p1);
            return direction.divideBy(this.vecLength());
        }
    }

    const points = [
        [50, 50],
        [250, 50],
        [250, 150],
        [50, 50]
    ];

    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 5;
    ctx.lineJoin = 'round';

    ctx.beginPath();

    // Start at first point
    ctx.moveTo(...points[0]);

    for (let i = 0; i < points.length - 2; i++) {
        const p0 = points[i];
        const p1 = points[i + 1];
        const p2 = points[i + 2];

        const v1 = new Vector2(p0, p1);
        const v2 = new Vector2(p1, p2);

        const dir1 = v1.normalise().multiplyBy(v1.vecLength() - radius);
        const dir2 = v2.normalise().multiplyBy(v2.vecLength() - radius);

        const p1Start = new CustomArray(...p0).add(dir1); // Point to stop before corner
        const p1End = new CustomArray(...p2).minus(dir2); // Point to resume after corner

        ctx.lineTo(...p1Start);
        ctx.arcTo(...p1, ...p1End, radius);
    }

    // Final point
    ctx.lineTo(...points[points.length - 1]);

    ctx.stroke();
    
    // ctx.fillStyle = 'blue'
    // ctx.beginPath()
    // ctx.arc(reducedCoord[0], reducedCoord[1], 5, 0, Math.PI * 2)
    // ctx.fill()
    // ctx.beginPath()
    // ctx.arc(...coord[1], 5, 0, Math.PI * 2)
    // ctx.fill()
    // ctx.beginPath()
    // ctx.arc(reducedCoord2[0], reducedCoord2[1], 5, 0, Math.PI * 2)
    // ctx.fill()
    // ctx.beginPath()
    // ctx.arc(reducedCoord3[0], reducedCoord3[1], 5, 0, Math.PI * 2)
    // ctx.fill()
    // ctx.beginPath()
    // ctx.arc(reducedCoord4[0], reducedCoord4[1], 5, 0, Math.PI * 2)
    // ctx.fill()
</script>

</html>